% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/st_or.R
\name{st_or}
\alias{st_or}
\title{\code{sf} equivalent of QGIS Union}
\usage{
st_or(x, y, dim = 2, x.suffix = ".x", y.suffix = ".y", suffix.all = FALSE)
}
\arguments{
\item{x}{object of class \code{sf} or \code{sfc}}

\item{y}{object of class \code{sf} or \code{sfc}}

\item{dim}{integer 0, 1, or 2 (default) for dimension of simple feature}

\item{x.suffix}{a single character strings (default \code{".x"}) attached as
suffix to attribute headings inherited from argument \code{x}}

\item{y.suffix}{a single character strings (default \code{".y"}) attached as
suffix to attribute headings inherited from argument \code{y}}

\item{suffix.all}{\code{TRUE} suffixes all attribute headings inherited from
arguments \code{x} and \code{y} according to \code{x.suffix}, resp.
\code{y.suffix}; \code{FALSE} (default) suffixes only homonymous attribute
headings.}
}
\value{
geometry set containing the intersection of \code{x} and \code{y} and
the non-overlapping parts of \code{x} and \code{y}. The attribute table is
filled with attribute values from the respective original geometry set for
non-overlapping features, and attribute values from both geometry sets for
overlapping features.
}
\description{
\code{sf} equivalent of QGIS Union
}
\details{
\code{st_or()} consists mainly of code presented by
\href{https://gis.stackexchange.com/questions/251440/ogr2ogr-equivalent-of-qgis-union/251575#251575}{TimSalbim on gis.stackexchange}
and some improvements put out by
\href{https://atriplex.info/blog/index.php/2018/07/12/full-spatial-polygon-union-intersection-with-r-sf/}{Jimbob on his blog}.
In addition to these two precursors this version of \code{st_or()} includes:
\itemize{
\item a more robust version of the internal function \code{st_erase()}
equivalent to \code{\link{st_erase_robust}}
\item the ability to handle homonymous attribute variables of both input
geometry sets (s. below examples)
\item the possibly to give customized suffixes to attribute variables
corresponding to the geometry set they originated from (s. below examples)
}
}
\examples{
library(sf)

st_or(poly_1, poly_2) \%>\% plot()

st_or(poly_1, poly_2) \%>\% st_drop_geometry()

# to avoid repeated warning messages triggered by non-spatially constant ...
# ... attribute variables, set them all to "constant":
st_agr(poly_1) <- "constant"
st_agr(poly_2) <- "constant"

# Give customized suffixes to homonymous attributes of layer x and y:
st_or(poly_1, poly_2, x.suffix = "_poly_1", y.suffix = "_poly_2") \%>\% plot()

# If only homonymous attributes from one layer should get a suffix, set ...
# ... the suffix for the other layer to an empty string:
st_or(poly_1, poly_2, x.suffix = "") \%>\% names()

# If all attributes attributes of both layer x and y should get a
# ... layer-specific suffix, set suffix.all = TRUE:
st_or(poly_1, poly_2, suffix.all = TRUE) \%>\% names()

# If only all attributes from one layer should get a suffix, set the suffix ...
# ... for the other layer to an empty string and set suffix.all = TRUE:
st_or(poly_1, poly_2, x.suffix = "", suffix.all = TRUE) \%>\% names()

}
